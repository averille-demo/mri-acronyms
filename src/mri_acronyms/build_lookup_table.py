"""Transform MRI acronym lookup tables to alternative representation.

Remove duplicates and drop vendor specific mappings.
"""

from pathlib import Path
from typing import Dict, List, Tuple, Union

import black
import pendulum

from mri_acronyms.models.pulse_sequence_category import PulseSequenceCategory
from mri_acronyms.models.validate_models import check_for_duplicates, dedup_acronyms
from mri_acronyms.util.logger import init_logger, relative_size

log = init_logger(caller=__file__)
MODULE = Path(__file__).resolve().name
CWD_PATH = Path(__file__).resolve().parent


def save_txt(
    path: Path,
    data: str,
) -> bool:
    """Save string data to disk.

    Args:
        path (Path): destination file path (with extension)
        data (str): payload to save

    Returns:
        True if file was written successfully
    """
    if path.is_file():
        path.unlink(missing_ok=True)
    if isinstance(data, str) and len(data) > 1:
        path.write_text(data=data, encoding="utf-8")
        if path.is_file() and path.stat().st_size > 1:
            log.info(f"saved: {relative_size(path)}")
            return True
    return False


def blacken_code_block(
    src_contents: str,
) -> str:
    """Reformat code block contents to with black auto-formatter.

    https://github.com/psf/black/blob/main/src/black/mode.py
    https://black.readthedocs.io/en/stable/contributing/reference/reference_classes.html#black.Mode
    https://github.com/psf/black/blob/main/src/black/__init__.py

    Args:
        src_contents (str): payload of raw code block

    Returns:
        str: formatted code block validated by black
    """
    mode = black.Mode(
        target_versions={black.TargetVersion.PY311},
        line_length=120,
        string_normalization=True,
        magic_trailing_comma=True,
        preview=False,
    )
    result = black.format_str(
        src_contents=src_contents,
        mode=mode,
    )
    return result


def format_entry_row(
    key: str,
    data_row: Union[List[str], Tuple[str]],
) -> List[str]:
    """Helper method for data formatting with applicable delimiters (square brackets/parentheses).

    Args:
        key (str): from dict
        data_row (List, Tuple):

    Returns:
        newline and indented formatted of tuple/list elements
    """
    indent = " " * 2
    lines = []
    if isinstance(data_row, tuple):
        delimiters = ("(", ")")
    elif isinstance(data_row, list):
        delimiters = ("[", "]")
    if isinstance(data_row, (List, Tuple)):
        formatted_line = f'{indent}"{key}": {delimiters[0]}\n'
        for element in data_row:
            formatted_line += f'{indent}{indent}"{element}",\n'
        formatted_line += f"{indent}{delimiters[1]},\n"
        lines.append(formatted_line)
    return lines


def save_to_py_file(
    name: str,
    docstring: str,
    code_block: Union[Dict, List, None],
) -> bool:
    """Save python data structure to '.py' file.

    allow flexibility for data input: Dict vs. List

    Args:
        name (str): variable declaration
        docstring (str): docstring for top of '.py' file
        code_block (Dict, List): payload of source code

    output:
             name --> CATEGORY_TO_ACRONYM_LUT = {
        code_block -> "apparent_diffusion_coefficient_map": ("adc",),
                 ...
        }

    Returns:
        True if file was saved successfully.
    """
    lines = []
    path = Path(CWD_PATH, "lut", f"{name.lower()}.py")
    if isinstance(code_block, Dict):
        lines.append(f"{docstring}\n{name}" + " = {\n")
        for category in code_block.keys():
            lines.append(f"'{category}'" + ": {\n")
            for key, val in code_block[category].items():
                lines.extend(format_entry_row(key, val))
            lines.append("},\n")
        lines.append("}\n")

    # convert single quotes to double, validate formatting
    formatted_str = blacken_code_block("".join(lines))
    print(f"\npreview: {path.name}\n{formatted_str[:1000]}\n...")
    return save_txt(path=path, data=formatted_str)


MRI_DOCSTRING = f"""
'''Grouped MR vendor acronyms by pulse sequence or scanning parameter.

auto-generated by '{MODULE}' on {pendulum.now().to_date_string()}

vendors: "Siemens", "GE", "Philips", "Canon", "Hitachi"
mri-category:
    key: pulse-sequence/parameter
    values: unique sorted set of all vendor acronyms (excluding duplicates and nulls)

https://pubs.rsna.org/doi/10.1148/rg.262055063
https://www.imaios.com/en/e-Courses/e-MRI/MRI-Sequences/Sequence-classification
https://www.imaios.com/en/e-Courses/e-MRI/MRI-Sequences/Sequences-acronyms
https://www.siemens-healthineers.com/en-us/magnetic-resonance-imaging/magnetom-world/publications/mr-basics
'''
"""


def get_unique_word_map(
    sort_values: bool,
) -> Dict[str, Dict[str, List[str]]]:
    """Create unique word list for given dictionary key in sorted order.

    Note: this breaks vendor-specific terminology mapping

    Args:
        sort_values (bool): reorder values in alphabetical order

    Returns:
        key: mri-category: {
                key: pulse-sequence/parameters {
                    values: list(vendor acronyms) sorted, unique
                        exclude duplicates
                        exclude NULLs
                }
            }
    """
    word_map: Dict[str, Dict[str, List[str]]] = {}
    for category in PulseSequenceCategory:
        word_map[category.name] = {}
        for model in category.acronyms:
            # initialize empty list for key
            word_map[category.name][model.name] = []
            # remove duplicates/nulls from tuple entry
            for word in dedup_acronyms(model=model):
                # avoid duplicates in mapping
                if word not in word_map[category.name][model.name]:
                    word_map[category.name][model.name].append(word)
            # for each key, sort values alphabetically
            if sort_values:
                word_map[category.name][model.name].sort()
    return word_map


def generate(sort_keys: bool) -> bool:
    """Creates lookup table mapping.

        key: MRI parameter/ pulse sequence type
        value: unique list of possible word matches (no duplicates) optional: lowercase

    Args:
        sort_keys (bool): sort nested dictionary by keys in alphabetical order

    Returns:
        True if file was written successfully
    """
    check_for_duplicates()
    word_map = get_unique_word_map(sort_values=True)
    if sort_keys:
        sorted_by_keys: Dict[str, Dict[str, List]] = {}
        for category in sorted(word_map.keys()):
            sorted_by_keys[category] = {}
            for acronym in sorted(word_map[category].keys()):
                sorted_by_keys[category][acronym] = word_map[category][acronym]
        code_block = sorted_by_keys
    else:
        code_block = word_map
    return save_to_py_file(name="CATEGORY_TO_ACRONYM_LUT", docstring=MRI_DOCSTRING, code_block=code_block)


if __name__ == "__main__":
    generate(sort_keys=False)
